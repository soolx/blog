<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Soolx"><title>前端监控 · Journey</title><meta name="description" content="前端监控系统踩坑（一）随着系统的功能不断的增加，慢慢就会有对各种指标、报错以及用户行为进行统计分析的需求产生。
通过分析采集的数据，来了解用户的需求，更有侧重的去完善功能，以便更好的贴近用户。
为什么需要前端监控系统
不了解哪些功能是用户高频使用的，哪些是无人问津的
有些功能的稳定性较差，需要进行异"><meta name="keywords"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><meta name="generator" content="Hexo 4.1.0"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">Journey</a></h3><div class="description"><p>Soolx's Blog</p></div></div></div><ul class="social-links"><li><a href="http://github.com/https://github.com/soolx" target="_blank" rel="noopener"><i class="fa fa-github"></i></a></li></ul><div class="footer"><a target="_blank" href="/">Soolx</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">PowerBy Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/about">关于</a></li><li><a href="/archives">归档</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div><div class="avatar"><img src="/images/dog.jpg"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>前端监控</a></h3></div><div class="post-content"><h1 id="前端监控系统踩坑（一）"><a href="#前端监控系统踩坑（一）" class="headerlink" title="前端监控系统踩坑（一）"></a>前端监控系统踩坑（一）</h1><p>随着系统的功能不断的增加，慢慢就会有对各种指标、报错以及用户行为进行统计分析的需求产生。</p>
<p>通过分析采集的数据，来了解用户的需求，更有侧重的去完善功能，以便更好的贴近用户。</p>
<h2 id="为什么需要前端监控系统"><a href="#为什么需要前端监控系统" class="headerlink" title="为什么需要前端监控系统"></a>为什么需要前端监控系统</h2><ul>
<li>不了解哪些功能是用户高频使用的，哪些是无人问津的</li>
<li>有些功能的稳定性较差，需要进行异常记录，方便排查bug甚至故障回放</li>
<li>记录页面的性能指标，接口调用时间，加载时间等，有针对性的进行优化</li>
</ul>
<h2 id="数据监控"><a href="#数据监控" class="headerlink" title="数据监控"></a>数据监控</h2><p>数据监控主要是用户记录用户行为。</p>
<p>主要包括：</p>
<ul>
<li><p>PV/UV:PV(page view)，即页面浏览量或点击量。UV:指访问某个站点的人数</p>
</li>
<li><p>用户在每一个页面的停留时间</p>
</li>
<li><p>用户通过什么入口来访问该网页</p>
</li>
<li><p>用户在相应的页面中触发的行为</p>
</li>
</ul>
<p>  通过记录并分析用户的行为，来确定功能迭代的优先级。给后续功能的增删提供有价值的参考指标。</p>
<h2 id="异常监控"><a href="#异常监控" class="headerlink" title="异常监控"></a>异常监控</h2><p>此外，产品的前端代码在执行过程中也会发生异常，因此需要引入异常监控。及时的上报异常情况，可以避免线上故障的发上。虽然大部分异常可以通过try catch的方式捕获，但是比如内存泄漏以及其他偶现的异常难以捕获。</p>
<p>主要包括：</p>
<ul>
<li>接口异常</li>
<li>资源加载异常</li>
<li>代码执行异常</li>
<li>样式丢失的异常监控</li>
</ul>
<h2 id="性能监控"><a href="#性能监控" class="headerlink" title="性能监控"></a>性能监控</h2><p>性能监控指的是监听前端的性能，主要包括监听网页或者说产品在用户端的体验。</p>
<p>主要包括：</p>
<ul>
<li>UA记录</li>
</ul>
<ul>
<li>不同用户，不同机型和不同系统下的首屏加载时间</li>
<li>白屏时间</li>
<li>http等请求的响应时间</li>
<li>静态资源整体下载时间</li>
<li>页面渲染时间</li>
<li>页面交互动画完成时间</li>
</ul>
<h2 id="常用前端埋点方案"><a href="#常用前端埋点方案" class="headerlink" title="常用前端埋点方案"></a>常用前端埋点方案</h2><h3 id="代码埋点"><a href="#代码埋点" class="headerlink" title="代码埋点"></a>代码埋点</h3><p>代码埋点，就是以嵌入代码的形式进行埋点，比如需要监控用户的点击事件，会选择在用户点击时，插入一段代码，保存这个监听行为或者直接将监听行为以某一种数据格式直接传递给server端。此外比如需要统计产品的PV和UV的时候，需要在网页的初始化时，发送用户的访问信息等。</p>
<p>优势：可以精细化的进行埋点</p>
<p>缺点：开发工作量较大，而且对业务代码有很大的侵入性</p>
<h3 id="可视化埋点"><a href="#可视化埋点" class="headerlink" title="可视化埋点"></a>可视化埋点</h3><p>通过可视化交互的手段，代替代码埋点。将业务代码和埋点代码分离，提供一个可视化交互的页面，输入为业务代码，通过这个可视化系统，可以在业务代码中自定义的增加埋点事件等等，最后输出的代码耦合了业务代码和埋点代码。</p>
<p>可视化埋点听起来比较高大上，实际上跟代码埋点还是区别不大。也就是用一个系统来实现手动插入代码埋点的过程。</p>
<p>优点：相对方便。</p>
<p>缺点：可视化埋点可以埋点的控件有限，不能手动定制，代码变更后可能会失效。</p>
<h3 id="无埋点（全埋点）"><a href="#无埋点（全埋点）" class="headerlink" title="无埋点（全埋点）"></a>无埋点（全埋点）</h3><p>无埋点并不是说不需要埋点，而是全部埋点，前端的任意一个事件都被绑定一个标识，所有的事件都别记录下来。通过定期上传记录文件，配合文件解析，解析出来我们想要的数据。</p>
<p>从语言层面实现无埋点也很简单，比如从页面的js代码中，找出dom上被绑定的事件，然后进行全埋点。</p>
<p>优点：</p>
<ul>
<li>由于采集的是全量数据，所以产品迭代过程中是不需要关注埋点逻辑的，也不会出现漏埋、误埋等现象</li>
</ul>
<p>缺点：</p>
<ul>
<li>无埋点采集全量数据，给数据传输和服务器增加压力</li>
<li>无法灵活的定制各个事件所需要上传的数据</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>考虑自研一个前端监控系统，先实现数据监控和性能监控，异常暂时使用Sentry实现。</p>
<p>第一个版本先实现接口调用的统计和PV记录，优先跑通流程，暂时不考虑鉴权和性能的问题。</p>
<p><img src="http://resource.soolx.top/image/png/Xnip2020-04-28_16-00-24.png" alt=""></p>
<p>如图，主要包含三个部分。</p>
<p>数据存储暂时使用postgres，后续根据使用情况可能考虑采用mongodb进行采集数据的存储，采用MQ来解决高并发的写入压力。</p>
<p>因为现在的系统大多是SPA，使用了前端路由进行管理。前端路由主要包含两种方案，hash和history。</p>
<p>hash方案可以通过监听hashchange实现监控</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">"hashchange"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  <span class="built_in">console</span>.log(event.oldURL, event.newURL)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&#125;, <span class="literal">false</span>);</span></pre></td></tr></table></figure>

<p>低版本做兼容的话大概是这样</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">window</span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 如果浏览器原生支持该事件,则退出  </span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( <span class="string">"onhashchange"</span> <span class="keyword">in</span> <span class="built_in">window</span>.document.body ) &#123; <span class="keyword">return</span>; &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">var</span> location = <span class="built_in">window</span>.location,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    oldURL = location.href,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    oldHash = location.hash;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 每隔100ms检测一下location.hash是否发生变化</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">  setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">var</span> newURL = location.href,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">      newHash = location.hash;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 如果hash发生了变化,且绑定了处理函数...</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> ( newHash != oldHash &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">window</span>.onhashchange === <span class="string">"function"</span> ) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">      <span class="comment">// execute the handler</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">      <span class="built_in">window</span>.onhashchange(&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">        type: <span class="string">"hashchange"</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">        oldURL: oldURL,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">        newURL: newURL</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">      &#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">      oldURL = newURL;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">      oldHash = newHash;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">  &#125;, <span class="number">100</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">&#125;)(<span class="built_in">window</span>);</span></pre></td></tr></table></figure>



<p>history可以通过监听popstate实现监控</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'popstate'</span>, (event) =&gt; &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  <span class="built_in">console</span>.log(<span class="string">"location: "</span> + <span class="built_in">document</span>.location + <span class="string">", state: "</span> + <span class="built_in">JSON</span>.stringify(event.state));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure>

<p>实践过程中有发现跟umi配置使用的时候，遇到监听不到Link跳转的问题，怀疑是react-router使用了history的polyfill的问题，暂时用了很low的方法进行测试</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">history.pushState = <span class="function"><span class="keyword">function</span>(<span class="params">state, title, url, first</span>)</span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (!first)&#123;<span class="built_in">console</span>.log(<span class="string">'record'</span>, url);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    history.pushState.apply(history, [state, title, url, <span class="literal">true</span>]);&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">history.replaceState = <span class="function"><span class="keyword">function</span>(<span class="params">state, title, url, first</span>)</span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (!first)&#123;<span class="built_in">console</span>.log(<span class="string">'record'</span>, url);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    history.replaceState.apply(history, [state, title, url, <span class="literal">true</span>]);&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>未完待续</p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2020-04-28</span><i class="fa fa-tag"></i></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" href="http://twitter.com/home?status=,http://blog.soolx.top/2020/04/28/monitor/,Journey,前端监控,;" target="_blank" rel="noopener"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2020/05/19/deno/" title="Deno">上一篇</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2020/03/31/websocket/" title="WebSocket实现设计">下一篇</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>